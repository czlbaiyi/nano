{"version":3,"sources":["assets/Script/Helloworld.ts","assets/Script/Nano.ts","assets/Script/Protocol.ts"],"names":["Nano_1","require","_a","cc","_decorator","ccclass","property","Helloworld","_super","__extends","_this","apply","this","arguments","label","text","prototype","start","string","Nano","init","host","port","__decorate","Label","Component","exports","default","Protocol_1","NanoEvent","NanoCode","Emitter","registMap","Map","on","type","callback","target","undefined","push","emit","customData","array","i","length","element","call","error","console","log","stack","off","offType","release","clear","JS_WS_CLIENT_TYPE","JS_WS_CLIENT_VERSION","decodeIO_encoder","decodeIO_decoder","EventEmitter","RES_OK","RES_FAIL","RES_OLD_CLIENT","socket","reqId","callbacks","handlers","routeMap","dict","abbrs","heartbeatInterval","heartbeatTimeout","nextHeartbeatTimeout","gapThreshold","heartbeatId","heartbeatTimeoutId","handshakeCallback","decode","encode","reconnect","reconncetTimer","reconnectUrl","reconnectAttempts","reconnectionDelay","DEFAULT_MAX_RECONNECT_ATTEMPTS","targetObj","initCallback","handler","handshakeBuffer","sys","version","rsa","user","Package","TYPE_HANDSHAKE","handshake","TYPE_HEARTBEAT","heartbeat","TYPE_DATA","onData","TYPE_KICK","onKick","params","cb","path","defaultEncode","defaultDecode","url","connect","data","msg","Message","id","route","body","deCompose","TYPE_REQUEST","TYPE_NOTIFY","Protocol","strencode","JSON","stringify","compressRoute","maxReconnectAttempts","self","onopen","event","reset","obj","send","onmessage","processPackage","Date","now","onerror","onclose","setTimeout","WebSocket","binaryType","disconnect","close","clearTimeout","request","thisObj","fail","sendMessage","success","failed","notify","packet","buffer","Uint8Array","byteLength","heartbeatTimeoutCb","gap","parse","strdecode","code","handshakeInit","TYPE_HANDSHAKE_ACK","processMessage","msgs","Array","isArray","ErrorID","processMessageBatch","l","initData","NanoInstance","copyArray","dest","doffset","src","soffset","copy","index","str","byteArray","ArrayBuffer","offset","charCode","charCodeAt","codes","j","_buffer","bytes","end","String","fromCharCode","PKG_HEAD_BYTES","rs","msgHasId","TYPE_RESPONSE","msgHasRoute","TYPE_PUSH","caculateMsgIdBytes","len","encodeMsgFlag","Error","MSG_FLAG_BYTES","encodeMsgId","tmp","next","Math","floor","encodeMsgRoute","MSG_ROUTE_CODE_MAX","encodeMsgBody","idBytes","msgLen","MSG_ROUTE_CODE_BYTES","MSG_ROUTE_LEN_BYTES","i_1","bytesLen","flag","MSG_COMPRESS_ROUTE_MASK","MSG_TYPE_MASK","m","parseInt","pow","routeLen","bodyLen","MSG_ID_MAX_BYTES"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAAA,IAAAA,SAAAC,QAAA;IAEM,IAAAC,KAAAC,GAAAC,YAAAC,UAAAH,GAAAG,SAAAC,WAAAJ,GAAAI;IAGN,IAAAC,aAAA,SAAAC;MAAwCC,UAAAF,YAAAC;MADxC,SAAAD;QAAA,IAAAG,QAAA,SAAAF,UAAAA,OAAAG,MAAAC,MAAAC,cAAAD;QAIIF,MAAAI,QAAA;QAGAJ,MAAAK,OAAA;;;MAEAR,WAAAS,UAAAC,QAAA;QAAA,IAAAP,QAAAE;QAEIA,KAAAE,MAAAI,SAAAN,KAAAG;QACAf,OAAAmB,KAAAC,KAAA;UAAAC,MAAA;UAAAC,MAAA;WAAA;UACIZ,MAAAI,MAAAI,SAAA;WACJN;;MAVJW,WAAA,EADCjB,SAAAH,GAAAqB,UACsBjB,WAAAS,WAAA,cAAA;MAGvBO,WAAA,EADCjB,YACsBC,WAAAS,WAAA,aAAA;MANNT,aAAAgB,WAAA,EADpBlB,WACoBE;MAerB,OAAAA;KAfA,CAAAJ,GAAAsB;IAAqBC,QAAAC,UAAApB;;;;;;;;;;;ICLrB,IAAAqB,aAAA3B,QAAA;IAGA,IAAA4B;KAAA,SAAAA;MACEA,UAAA,mBAAA;MADF,CAEAA,YAAAH,QAAAG,cAAAH,QAAAG,YAAA;IAEA,IAAAC;KAAA,SAAAA;MACEA,SAAAA,SAAA,cAAA,KAAA;MACAA,SAAAA,SAAA,QAAA,KAAA;MAFF,CAGAA,WAAAJ,QAAAI,aAAAJ,QAAAI,WAAA;IAOA,IAAAC,UAAA;MAAA,SAAAA;QACUnB,KAAAoB,YAAA,IAAAC;;MAEDF,QAAAf,UAAAkB,KAAA,SAAAC,MAAAC,UAAAC;aACLC,MAAA1B,KAAAoB,UAAAG,UACEvB,KAAAoB,UAAAG,QAAA;QAEFvB,KAAAoB,UAAAG,MAAAI,KAAA;UACEH,UAAAA;UACAC,QAAAA;;;MAIGN,QAAAf,UAAAwB,OAAA,SAAAL,MAAAM;QACL,IAAAC,QAAA9B,KAAAoB,UAAAG;QACA,SAAAG,MAAAI,OACE;QAGF,KAAA,IAAAC,IAAA,GAAAA,IAAAD,MAAAE,QAAAD,KAAA;UACE,IAAAE,UAAAH,MAAAC;UACA,IAAAE,SAEE;YACEA,QAAAT,SAAAU,KAAAD,QAAAR,QAAAI;YACA,OAAAM;YACAC,QAAAC,IAAA,uBAAAF,MAAAG;;;;MAODnB,QAAAf,UAAAmC,MAAA,SAAAhB,MAAAC;QACL,IAAAM,QAAA9B,KAAAoB,UAAAG;QACA,SAAAG,MAAAI,OACE;QAGF,KAAA,IAAAC,IAAA,GAAAA,IAAAD,MAAAE,QAAAD,KAAA;UACE,IAAAE,UAAAH,MAAAC;UACA,IAAAE,WAAAA,QAAAT,aAAAA,UAAA;YACEM,MAAAC,UAAAL;YACA;;;;MAKCP,QAAAf,UAAAoC,UAAA,SAAAjB;QACLvB,KAAAoB,UAAAG,aAAAG;;MAGKP,QAAAf,UAAAqC,UAAA;QACLzC,KAAAoB,UAAAsB;;MAEJ,OAAAvB;KAvDA;IAyDA,IAAAZ,OAAA,SAAAX;MAAmBC,UAAAU,MAAAX;MAuCjB,SAAAW;QAAA,IAAAT,QAAAF,OAAAsC,KAAAlC,SAAAA;QAtCAF,MAAA6C,oBAAA;QACA7C,MAAA8C,uBAAA;QAEA9C,MAAA+C,mBAAA;QACA/C,MAAAgD,mBAAA;QACAhD,MAAAiD,eAAA5B;QAEArB,MAAAkD,SAAA;QACAlD,MAAAmD,WAAA;QACAnD,MAAAoD,iBAAA;QAEApD,MAAAqD,SAAA;QACArD,MAAAsD,QAAA;QACAtD,MAAAuD,YAAA;QACAvD,MAAAwD,WAAA;QAEAxD,MAAAyD,WAAA;QACAzD,MAAA0D,OAAA;QACA1D,MAAA2D,QAAA;QACA3D,MAAA4D,oBAAA;QACA5D,MAAA6D,mBAAA;QACA7D,MAAA8D,uBAAA;QACA9D,MAAA+D,eAAA;QACA/D,MAAAgE,cAAA;QACAhE,MAAAiE,qBAAA;QACAjE,MAAAkE,oBAAA;QACAlE,MAAAmE,SAAA;QACAnE,MAAAoE,SAAA;QACApE,MAAAqE,YAAA;QACArE,MAAAsE,iBAAA;QACAtE,MAAAuE,eAAA;QACAvE,MAAAwE,oBAAA;QACAxE,MAAAyE,oBAAA;QACAzE,MAAA0E,iCAAA;QACA1E,MAAA2E,YAAA;QACA3E,MAAA4E,eAAA;QACA5E,MAAA6E,UAAA;QAUA7E,MAAA8E,kBAAA;UACEC,KAAA;YACEtD,MAAAzB,MAAA6C;YACAmC,SAAAhF,MAAA8C;YACAmC,KAAA;;UAEFC,MAAA;;QAZAlF,MAAAwD,SAAAtC,WAAAiE,QAAAC,kBAAApF,MAAAqF;QACArF,MAAAwD,SAAAtC,WAAAiE,QAAAG,kBAAAtF,MAAAuF;QACAvF,MAAAwD,SAAAtC,WAAAiE,QAAAK,aAAAxF,MAAAyF;QACAzF,MAAAwD,SAAAtC,WAAAiE,QAAAO,aAAA1F,MAAA2F;;;MAaKlF,KAAAH,UAAAI,OAAA,SAAAkF,QAAAC,IAAAlE;QACLzB,KAAA0E,eAAAiB;QACA3F,KAAAyE,YAAAhD;QACA,IAAAhB,OAAAiF,OAAAjF;QACA,IAAAC,OAAAgF,OAAAhF;QACA,IAAAkF,OAAAF,OAAAE;QAEA5F,KAAAkE,SAAAwB,OAAAxB,UAAAlE,KAAA6F;QACA7F,KAAAiE,SAAAyB,OAAAzB,UAAAjE,KAAA8F;QAEA,IAAAC,MAAA,UAAAtF;QACAC,SACEqF,OAAA,MAAArF;QAGFkF,SACEG,OAAAH;QAGF5F,KAAA4E,gBAAAI,OAAAU,OAAAV;QACAhF,KAAAgE,oBAAA0B,OAAA1B;QACAhE,KAAAgG,QAAAN,QAAAK,KAAAJ;;MAGMpF,KAAAH,UAAA0F,gBAAA,SAAAG;QACN,IAAAC,MAAAlF,WAAAmF,QAAAlC,OAAAgC;QAEA,IAAAC,IAAAE,KAAA,GAAA;UACEF,IAAAG,QAAArG,KAAAuD,SAAA2C,IAAAE;iBACApG,KAAAuD,SAAA2C,IAAAE;UACA,KAAAF,IAAAG,OACE;;QAIJH,IAAAI,OAAAtG,KAAAuG,UAAAL;QACA,OAAAA;;MAGM3F,KAAAH,UAAAyF,gBAAA,SAAAzC,OAAAiD,OAAAH;QACN,IAAA3E,OAAA6B,QAAApC,WAAAmF,QAAAK,eAAAxF,WAAAmF,QAAAM;QACAP,MAAAlF,WAAA0F,SAAAC,UAAAC,KAAAC,UAAAX;QAEA,IAAAY,gBAAA;QACA,IAAA9G,KAAAwD,QAAAxD,KAAAwD,KAAA6C,QAAA;UACEA,QAAArG,KAAAwD,KAAA6C;UACAS,gBAAA;;QAGF,OAAA9F,WAAAmF,QAAAjC,OAAAd,OAAA7B,MAAAuF,eAAAT,OAAAH;;MAGM3F,KAAAH,UAAA4F,UAAA,SAAAN,QAAAK,KAAAJ;QACNvD,QAAAC,IAAA,gBAAA0D;QAEA,IAAAL,SAAAA,UAAA;QACA,IAAAqB,uBAAArB,OAAAqB,wBAAA/G,KAAAwE;QACAxE,KAAAqE,eAAA0B;QACA,IAAAiB,OAAAhH;QACA,IAAAiH,SAAA,SAAAC;WACEF,KAAA7C,aACE6C,KAAApF,KAAA;UAEFoF,KAAAG;UACA/E,QAAAC,IAAA;UACAD,QAAAC,IAAA;UACA,IAAA+E,MAAApG,WAAAiE,QAAAf,OAAAlD,WAAAiE,QAAAC,gBAAAlE,WAAA0F,SAAAC,UAAAC,KAAAC,UAAAG,KAAApC;UACAoC,KAAAK,KAAAD;;QAEF,IAAAE,YAAA,SAAAJ;UACEF,KAAAO,eAAAvG,WAAAiE,QAAAhB,OAAAiD,MAAAjB;UAEAe,KAAArD,qBACEqD,KAAApD,uBAAA4D,KAAAC,QAAAT,KAAArD;;QAGJ,IAAA+D,UAAA,SAAAR;UACEF,KAAApF,KAAA,YAAAsF;UACA9E,QAAAD,MAAA,kBAAA+E;;QAEF,IAAAS,UAAA,SAAAT;UACEF,KAAApF,KAAA,SAAAsF;UACAF,KAAApF,KAAA,cAAAsF;UACA9E,QAAAC,IAAA,kBAAA6E;UACA,MAAAxB,OAAAvB,aAAA6C,KAAA1C,oBAAAyC,sBAAA;YACEC,KAAA7C,YAAA;YACA6C,KAAA1C;YACA0C,KAAA5C,iBAAAwD,WAAA;cACEZ,KAAAhB,QAAAN,QAAAsB,KAAA3C,cAAAsB;eACFqB,KAAAzC;YACAyC,KAAAzC,qBAAA;;;QAGJvE,KAAAmD,SAAA,IAAA0E,UAAA9B;QACA/F,KAAAmD,OAAA2E,aAAA;QACA9H,KAAAmD,OAAA8D,SAAAA;QACAjH,KAAAmD,OAAAmE,YAAAA;QACAtH,KAAAmD,OAAAuE,UAAAA;QACA1H,KAAAmD,OAAAwE,UAAAA;;MAGKpH,KAAAH,UAAA2H,aAAA;QACL,IAAA/H,KAAAmD,QAAA;UACEnD,KAAAmD,OAAA4E,cAA4B/H,KAAAmD,OAAA4E;UAC5B/H,KAAAmD,OAAA6E,SAAuBhI,KAAAmD,OAAA6E;UACvB5F,QAAAC,IAAA;UACArC,KAAAmD,SAAA;;QAGF,IAAAnD,KAAA8D,aAAA;UACEmE,aAAAjI,KAAA8D;UACA9D,KAAA8D,cAAA;;QAEF,IAAA9D,KAAA+D,oBAAA;UACEkE,aAAAjI,KAAA+D;UACA/D,KAAA+D,qBAAA;;;MAIGxD,KAAAH,UAAA+G,QAAA;QACLnH,KAAAmE,YAAA;QACAnE,KAAAuE,oBAAA;QACAvE,KAAAsE,oBAAA;QACA2D,aAAAjI,KAAAoE;;MAGK7D,KAAAH,UAAA8H,UAAA,SAAA7B,OAAAH,KAAAP,IAAAwC,SAAAC;aAAgE,MAAAA,SAAAA,OAAA;QACrE,IAAA,MAAAnI,UAAA+B,UAAA,sBAAAkE,KAAA;UACEP,KAAAO;UACAA,MAAA;eAEAA,MAAAA,OAAA;QAEFG,QAAAA,SAAAH,IAAAG;QACA,KAAAA,OACE;QAGFrG,KAAAoD;QACApD,KAAAqI,YAAArI,KAAAoD,OAAAiD,OAAAH;QAEAlG,KAAAqD,UAAArD,KAAAoD,SAAA;UAAA3B,QAAA0G;UAAAG,SAAA3C;UAAA4C,QAAAH;;QACApI,KAAAuD,SAAAvD,KAAAoD,SAAAiD;;MAGK9F,KAAAH,UAAAoI,SAAA,SAAAnC,OAAAH;QACLA,MAAAA,OAAA;QACAlG,KAAAqI,YAAA,GAAAhC,OAAAH;;MAGM3F,KAAAH,UAAAiI,cAAA,SAAAjF,OAAAiD,OAAAH;QACNlG,KAAAkE,WACEgC,MAAAlG,KAAAkE,OAAAd,OAAAiD,OAAAH;QAEF,IAAAuC,SAAAzH,WAAAiE,QAAAf,OAAAlD,WAAAiE,QAAAK,WAAAY;QACAlG,KAAAqH,KAAAoB;;MAGMlI,KAAAH,UAAAiH,OAAA,SAAAoB;QACN,IAAAC,SAAA,IAAAC,WAAAF,OAAAG;QACA,KAAA,IAAA7G,IAAA,GAAAA,IAAA0G,OAAAG,cAAA7G,GACE2G,OAAA3G,KAAA0G,OAAA1G;QAEF/B,KAAAmD,OAAAkE,KAAAqB;;MAGMnI,KAAAH,UAAAiF,YAAA,SAAAY;QAAR,IAAAnG,QAAAE;QACE,KAAAA,KAAA0D,mBAEE;QAGF,IAAA0D,MAAApG,WAAAiE,QAAAf,OAAAlD,WAAAiE,QAAAG,qBAAA1D;QACA,IAAA1B,KAAA+D,oBAAA;UACEkE,aAAAjI,KAAA+D;UACA/D,KAAA+D,qBAAA;;QAGF,IAAA/D,KAAA8D,aAEE;QAEF9D,KAAA8D,cAAA8D,WAAA;UACE9H,MAAAgE,cAAA;UACAhE,MAAAuH,KAAAD;UAEAtH,MAAA8D,uBAAA4D,KAAAC,QAAA3H,MAAA6D;UACA7D,MAAAiE,qBAAA6D,WAAA;YACE9H,MAAA+I;aACF/I,MAAA6D;WACF3D,KAAA0D;;MAGMnD,KAAAH,UAAAyI,qBAAA;QAAR,IAAA/I,QAAAE;QACE,IAAA8I,MAAA9I,KAAA4D,uBAAA4D,KAAAC;QACA,IAAAqB,MAAA9I,KAAA6D,cACE7D,KAAA+D,qBAAA6D,WAAA;UAAA9H,MAAA+I;WAAAC,WACK;UACL1G,QAAAD,MAAA;UACAnC,KAAA4B,KAAA;UACA5B,KAAA+H;;;MAIIxH,KAAAH,UAAA+E,YAAA,SAAAc;QACNA,OAAAW,KAAAmC,MAAA/H,WAAA0F,SAAAsC,UAAA/C;QACA,GAAA;UACE,IAAAA,KAAAgD,SAAAjJ,KAAAkD,gBAAA;YACElD,KAAA4B,KAAA,SAAA;YACA;;UAGF,IAAAqE,KAAAgD,SAAAjJ,KAAAgD,QAAA;YACEhD,KAAA4B,KAAA,SAAA;YACA;;UAGF5B,KAAAkJ,cAAAjD;UACA,IAAAmB,MAAApG,WAAAiE,QAAAf,OAAAlD,WAAAiE,QAAAkE,yBAAAzH;UACA1B,KAAAqH,KAAAD;iBACD;QAEDpH,KAAA0E,gBAAA1E,KAAAyE,aACEzE,KAAA0E,aAAAxC,KAAAlC,KAAAmD,QAAA8C,KAAAgD;;MAII1I,KAAAH,UAAAmF,SAAA,SAAAU;QACN,IAAAC,MAAAD;QACAjG,KAAAiE,WACEiC,MAAAlG,KAAAiE,OAAAiC;QAEFlG,KAAAoJ,eAAAlD;;MAGM3F,KAAAH,UAAAqF,SAAA,SAAAQ;QACNA,OAAAW,KAAAmC,MAAA/H,WAAA0F,SAAAsC,UAAA/C;QACAjG,KAAA4B,KAAA,UAAAqE;;MAGM1F,KAAAH,UAAAmH,iBAAA,SAAA8B;QACN,IAAAC,MAAAC,QAAAF,OACE,KAAA,IAAAtH,IAAA,GAAAA,IAAAsH,KAAArH,QAAAD,KAAA;UACE,IAAAmE,MAAAmD,KAAAtH;UACA/B,KAAAsD,SAAA4C,IAAA3E,MAAAW,KAAAlC,MAAAkG,IAAAI;eAGFtG,KAAAsD,SAAA+F,KAAA9H,MAAAW,KAAAlC,MAAAqJ,KAAA/C;;MAGI/F,KAAAH,UAAAgJ,iBAAA,SAAAlD;QACN,KAAAA,IAAAE,IAAA;UAEEpG,KAAA4B,KAAAsE,IAAAG,OAAAH,IAAAI;UACA;;QAYF,IAAAX,KAAA3F,KAAAqD,UAAA6C,IAAAE;eAEApG,KAAAqD,UAAA6C,IAAAE;QAEA,IAAA,sBAAAT,GAAA2C,WAAApC,IAAAI,QAAAJ,IAAAI,KAAA2C,QAAA/H,SAAAsI,SACE7D,GAAAlE,SAAAkE,GAAA2C,QAAApG,KAAAyD,GAAAlE,QAAAyE,IAAAI,QAAAX,GAAA2C,QAAApC,IAAAI,YAEG;UAAA,IAAA,sBAAAX,GAAA4C,QAIH,MAAA;UAHA5C,GAAAlE,SAAAkE,GAAA4C,OAAArG,KAAAyD,GAAAlE,QAAAyE,IAAAI,QAAAX,GAAA4C,OAAArC,IAAAI;;;MAOI/F,KAAAH,UAAAqJ,sBAAA,SAAAJ;QACN,KAAA,IAAAtH,IAAA,GAAA2H,IAAAL,KAAArH,QAAAD,IAAA2H,GAAA3H,KACE/B,KAAAoJ,eAAAC,KAAAtH;;MAIIxB,KAAAH,UAAAmG,YAAA,SAAAL;QACN,IAAAG,QAAAH,IAAAG;QAGA,IAAAH,IAAAY,eAAA;UACE,KAAA9G,KAAAyD,MAAA4C,QACE,OAAA;UAGFA,QAAAH,IAAAG,QAAArG,KAAAyD,MAAA4C;;QAEF,OAAAO,KAAAmC,MAAA/H,WAAA0F,SAAAsC,UAAA9C,IAAAI;;MAGM/F,KAAAH,UAAA8I,gBAAA,SAAAjD;QACN,IAAAA,KAAApB,OAAAoB,KAAApB,IAAAQ,WAAA;UACErF,KAAA0D,oBAAA,MAAAuC,KAAApB,IAAAQ;UACArF,KAAA2D,mBAAA,IAAA3D,KAAA0D;eACK;UACL1D,KAAA0D,oBAAA;UACA1D,KAAA2D,mBAAA;;QAGF3D,KAAA2J,SAAA1D;QAEA,sBAAAjG,KAAAgE,qBACEhE,KAAAgE,kBAAAiC,KAAAjB;;MAIIzE,KAAAH,UAAAuJ,WAAA,SAAA1D;QACN,KAAAA,SAAAA,KAAApB,KACE;QAEF7E,KAAAwD,OAAAyC,KAAApB,IAAArB;QAGA,IAAAxD,KAAAwD,MAAA;UACExD,KAAAyD,QAAA;UAEA,KAAA,IAAA4C,SAAArG,KAAAwD,MACExD,KAAAyD,MAAAzD,KAAAwD,KAAA6C,UAAAA;;;MAIR,OAAA9F;KArYA,CAqYAY;IAEA,IAAAyI,eAAA,IAAArJ;IACyBO,QAAAP,OAAAqJ;;;;;;;;;;;IC1czB,SAAAC,UAAAC,MAAAC,SAAAC,KAAAC,SAAAjI;MACE,IAAA,sBAAAgI,IAAAE,MAEEF,IAAAE,KAAAJ,MAAAC,SAAAE,SAAAA,UAAAjI,cAGA,KAAA,IAAAmI,QAAA,GAAAA,QAAAnI,QAAAmI,SACEL,KAAAC,aAAAC,IAAAC;;IAKN,IAAAvD,WAAA;MAAA,SAAAA;MAQSA,SAAAC,YAAA,SAAAyD;QACL,IAAAC,YAAA,IAAAC,YAAA,IAAAF,IAAApI;QACA,IAAAuI,SAAA;QACA,KAAA,IAAAxI,IAAA,GAAAA,IAAAqI,IAAApI,QAAAD,KAAA;UACE,IAAAyI,WAAAJ,IAAAK,WAAA1I;UACA,IAAA2I,QAAA;UAEEA,QADFF,YAAA,MACE,EAAAA,aACKA,YAAA,OACL,EAAA,MAAAA,YAAA,GAAA,MAAA,KAAAA,aAEA,EAAA,MAAAA,YAAA,IAAA,OAAA,OAAAA,aAAA,GAAA,MAAA,KAAAA;UAEF,KAAA,IAAAG,IAAA,GAAAA,IAAAD,MAAA1I,QAAA2I,KAAA;YACEN,UAAAE,UAAAG,MAAAC;cACAJ;;;QAGJ,IAAAK,UAAA,IAAAN,YAAAC;QACAV,UAAAe,SAAA,GAAAP,WAAA,GAAAE;QACA,OAAAK;;MAQKlE,SAAAsC,YAAA,SAAAN;QACL,IAAAmC,QAAA,IAAAlC,WAAAD,OAAAE;QACA,KAAA,IAAA7G,IAAA,GAAAA,IAAA2G,OAAAE,cAAA7G,GACE8I,MAAA9I,KAAA2G,OAAA3G;QAEF,IAAAD,QAAA;QACA,IAAAyI,SAAA;QACA,IAAAC,WAAA;QACA,IAAAM,MAAAD,MAAAjC;QACA,OAAA2B,SAAAO,KAAA;UACE,IAAAD,MAAAN,UAAA,KAAA;YACEC,WAAAK,MAAAN;YACAA,UAAA;iBACK,IAAAM,MAAAN,UAAA,KAAA;YACLC,aAAA,KAAAK,MAAAN,YAAA,MAAA,KAAAM,MAAAN,SAAA;YACAA,UAAA;iBACK;YACLC,aAAA,KAAAK,MAAAN,YAAA,QAAA,KAAAM,MAAAN,SAAA,OAAA,MAAA,KAAAM,MAAAN,SAAA;YACAA,UAAA;;UAEFzI,MAAAH,KAAA6I;;QAEF,OAAAO,OAAAC,aAAAjL,MAAA,MAAA+B;;MAEJ,OAAA4E;KA5DA;IAAa5F,QAAA4F,WAAAA;IA+Db,IAAAzB,UAAA;MAAA,SAAAA;MA8BSA,QAAAf,SAAA,SAAA3C,MAAA+E;QACL,IAAAtE,SAAAsE,OAAAA,KAAAsC,aAAA;QACA,IAAAF,SAAA,IAAA4B,YAAArF,QAAAgG,iBAAAjJ;QACA,IAAAmI,QAAA;QACAzB,OAAAyB,WAAA,MAAA5I;QACAmH,OAAAyB,WAAAnI,UAAA,KAAA;QACA0G,OAAAyB,WAAAnI,UAAA,IAAA;QACA0G,OAAAyB,WAAA,MAAAnI;QACAsE,QACEuD,UAAAnB,QAAAyB,OAAA7D,MAAA,GAAAtE;QAEF,OAAA0G;;MAUKzD,QAAAhB,SAAA,SAAAyE;QACL,IAAA6B,SAAA;QACA,IAAAM,QAAA,IAAAlC,WAAAD;QACA,IAAA1G,SAAA;QACA,IAAAkJ,KAAA;QACA,OAAAX,SAAAM,MAAAjC,YAAA;UACE,IAAArH,OAAAsJ,MAAAN;UACAvI,UAAA6I,MAAAN,aAAA,KAAAM,MAAAN,aAAA,IAAAM,MAAAN,eAAA;UACA,IAAAjE,OAAAtE,SAAA,IAAAsI,YAAAtI,UAAA;UACA6H,UAAAvD,MAAA,GAAAuE,OAAAN,QAAAvI;UACAuI,UAAAvI;UACAkJ,GAAAvJ,KAAA;YAAAJ,MAAAA;YAAA+E,MAAAA;;;QAEF,OAAA,MAAA4E,GAAAlJ,SAAAkJ,GAAA,KAAAA;;MA/DKjG,QAAAgG,iBAAA;MACAhG,QAAAC,iBAAA;MACAD,QAAAkE,qBAAA;MACAlE,QAAAG,iBAAA;MACAH,QAAAK,YAAA;MACAL,QAAAO,YAAA;MA4DT,OAAAP;KAlEA;IAAanE,QAAAmE,UAAAA;IAqEb,IAAAkB,UAAA;MAAA,SAAAA;MAiBSA,QAAAgF,WAAA,SAAA5J;QACL,OAAAA,SAAA4E,QAAAK,gBAAAjF,SAAA4E,QAAAiF;;MAGKjF,QAAAkF,cAAA,SAAA9J;QACL,OAAAA,SAAA4E,QAAAK,gBAAAjF,SAAA4E,QAAAM,eACElF,SAAA4E,QAAAmF;;MAGGnF,QAAAoF,qBAAA,SAAAnF;QACL,IAAAoF,MAAA;QACA,GAAA;UACEA,OAAA;UACApF,OAAA;iBACDA,KAAA;QACD,OAAAoF;;MAGKrF,QAAAsF,gBAAA,SAAAlK,MAAAuF,eAAA4B,QAAA6B;QACL,IAAAhJ,SAAA4E,QAAAK,gBAAAjF,SAAA4E,QAAAM,eACElF,SAAA4E,QAAAiF,iBAAA7J,SAAA4E,QAAAmF,WACA,MAAA,IAAAI,MAAA,0BAAAnK;QAGFmH,OAAA6B,UAAAhJ,QAAA,KAAAuF,gBAAA,IAAA;QAEA,OAAAyD,SAAApE,QAAAwF;;MAGKxF,QAAAyF,cAAA,SAAAxF,IAAAsC,QAAA6B;QACL,GAAA;UACE,IAAAsB,MAAAzF,KAAA;UACA,IAAA0F,OAAAC,KAAAC,MAAA5F,KAAA;UAEA,MAAA0F,SACED,OAAA;UAEFnD,OAAA6B,YAAAsB;UAEAzF,KAAA0F;iBACD,MAAA1F;QAED,OAAAmE;;MAGKpE,QAAA8F,iBAAA,SAAAnF,eAAAT,OAAAqC,QAAA6B;QACL,IAAAzD,eAAA;UACE,IAAAT,QAAAF,QAAA+F,oBACE,MAAA,IAAAR,MAAA;UAGFhD,OAAA6B,YAAAlE,SAAA,IAAA;UACAqC,OAAA6B,YAAA,MAAAlE;eAEA,IAAAA,OAAA;UACEqC,OAAA6B,YAAA,MAAAlE,MAAAuC;UACAiB,UAAAnB,QAAA6B,QAAAlE,OAAA,GAAAA,MAAAuC;UACA2B,UAAAlE,MAAAuC;eAEAF,OAAA6B,YAAA;QAIJ,OAAAA;;MAGKpE,QAAAgG,gBAAA,SAAAjG,KAAAwC,QAAA6B;QACLV,UAAAnB,QAAA6B,QAAArE,KAAA,GAAAA,IAAA0C;QACA,OAAA2B,SAAArE,IAAA0C;;MAcKzC,QAAAjC,SAAA,SAAAkC,IAAA7E,MAAAuF,eAAAT,OAAAH;QAEL,IAAAkG,UAAAjG,QAAAgF,SAAA5J,QAAA4E,QAAAoF,mBAAAnF,MAAA;QACA,IAAAiG,SAAAlG,QAAAwF,iBAAAS;QAEA,IAAAjG,QAAAkF,YAAA9J,OACE,IAAAuF,eAAA;UACE,IAAA,oBAAAT,OACE,MAAA,IAAAqF,MAAA;UAEFW,UAAAlG,QAAAmG;eACK;UACLD,UAAAlG,QAAAoG;UACA,IAAAlG,OAAA;YACEA,QAAAK,SAAAC,UAAAN;YACA,IAAAA,MAAArE,SAAA,KACE,MAAA,IAAA0J,MAAA;YAEFW,UAAAhG,MAAAuC;;;QAKN1C,QACEmG,UAAAnG,IAAA0C;QAGF,IAAAF,SAAA,IAAA4B,YAAA+B;QACA,IAAA9B,SAAA;QAGAA,SAAApE,QAAAsF,cAAAlK,MAAAuF,eAAA4B,QAAA6B;QAGApE,QAAAgF,SAAA5J,UACEgJ,SAAApE,QAAAyF,YAAAxF,IAAAsC,QAAA6B;QAIFpE,QAAAkF,YAAA9J,UACEgJ,SAAApE,QAAA8F,eAAAnF,eAAAT,OAAAqC,QAAA6B;QAIFrE,QACEqE,SAAApE,QAAAgG,cAAAjG,KAAAwC,QAAA6B;QAGF,OAAA7B;;MASKvC,QAAAlC,SAAA,SAAAyE;QACL,IAAAmC,QAAA,IAAAP,YAAA5B,OAAAE;QACA,KAAA,IAAA4D,MAAA,GAAAA,MAAA9D,OAAAE,cAAA4D,KACE3B,MAAA2B,OAAA9D,OAAA8D;QAGF,IAAAC,WAAA5B,MAAAjC;QACA,IAAA2B,SAAA;QACA,IAAAnE,KAAA;QACA,IAAAC,QAAA;QAGA,IAAAqG,OAAA7B,MAAAN;QACA,IAAAzD,gBAAA4F,OAAAvG,QAAAwG;QACA,IAAApL,OAAAmL,QAAA,IAAAvG,QAAAyG;QAGA,IAAAzG,QAAAgF,SAAA5J,OAAA;UACE,IAAAsL,IAAAC,SAAAjC,MAAAN;UACA,IAAAxI,IAAA;UACA,GAAA;YACE,IAAA8K,IAAAC,SAAAjC,MAAAN;YACAnE,OAAA,MAAAyG,KAAAd,KAAAgB,IAAA,GAAA,IAAAhL;YACAwI;YACAxI;mBACD8K,KAAA;;QAIH,IAAA1G,QAAAkF,YAAA9J,OACE,IAAAuF,eACET,QAAAwE,MAAAN,aAAA,IAAAM,MAAAN,gBACK;UACL,IAAAyC,WAAAnC,MAAAN;UACA,IAAAyC,UAAA;YACE3G,QAAA,IAAAiE,YAAA0C;YACAnD,UAAAxD,OAAA,GAAAwE,OAAAN,QAAAyC;YACA3G,QAAAK,SAAAsC,UAAA3C;iBAEAA,QAAA;UAEFkE,UAAAyC;;QAKJ,IAAAC,UAAAR,WAAAlC;QACA,IAAAjE,OAAA,IAAAgE,YAAA2C;QAEApD,UAAAvD,MAAA,GAAAuE,OAAAN,QAAA0C;QAEA,OAAA;UACE7G,IAAAA;UAAA7E,MAAAA;UAAAuF,eAAAA;UACAT,OAAAA;UAAAC,MAAAA;;;MAhNGH,QAAAK,eAAA;MACAL,QAAAM,cAAA;MACAN,QAAAiF,gBAAA;MACAjF,QAAAmF,YAAA;MAEAnF,QAAAwF,iBAAA;MACAxF,QAAAmG,uBAAA;MACAnG,QAAA+G,mBAAA;MACA/G,QAAAoG,sBAAA;MAEApG,QAAA+F,qBAAA;MAEA/F,QAAAwG,0BAAA;MACAxG,QAAAyG,gBAAA;MAuMT,OAAAzG;KArNA;IAAarF,QAAAqF,UAAAA","sourcesContent":["import { Nano } from \"./Nano\"\n\nconst { ccclass, property } = cc._decorator;\n\n@ccclass\nexport default class Helloworld extends cc.Component {\n\n    @property(cc.Label)\n    label: cc.Label = null;\n\n    @property\n    text: string = 'hello';\n\n    start() {\n        // init logic\n        this.label.string = this.text;\n        Nano.init({ host: \"127.0.0.1\", port: 33251 }, ()=>{\n            this.label.string = \"connect success\"\n        }, this)\n    }\n}\n","import { Package, Protocol, Message } from \"./Protocol\";\n// import { ByteArray } from \"./ByteArray\"\n\nexport enum NanoEvent {\n  MSG_PRASE_ERR = \"MSG_PRASE_ERR\"\n}\n\nexport enum NanoCode {\n  ErrorID = -1,\n  Ok = 0,\n}\n\n\n/**\n * 事件类型\n */\n\nclass Emitter {\n  private registMap: Map<string, any> = new Map<string, any>();\n\n  public on(type: string, callback: Function, target: Object) {\n    if (this.registMap[type] === undefined) {\n      this.registMap[type] = [];\n    }\n    this.registMap[type].push({\n      callback: callback,\n      target: target\n    });\n  };\n\n  public emit(type: string, customData?: any) {\n    var array = this.registMap[type];\n    if (array === undefined) {\n      return;\n    }\n\n    for (var i = 0; i < array.length; i++) {\n      var element = array[i];\n      if (element) {\n        // call 报错没有反应\n        try {\n          element.callback.call(element.target, customData);\n        } catch (error) {\n          console.log(\"call function error\", error.stack);\n        }\n\n      }\n    }\n  };\n\n  public off(type: string, callback: Function) {\n    var array = this.registMap[type];\n    if (array === undefined) {\n      return;\n    }\n\n    for (var i = 0; i < array.length; i++) {\n      var element = array[i];\n      if (element && element.callback === callback) {\n        array[i] = undefined;\n        break;\n      }\n    }\n  };\n\n  public offType(type: string) {\n    this.registMap[type] = undefined;\n  };\n\n  public release() {\n    this.registMap.clear();\n  };\n}\n\nclass Nano extends Emitter {\n  JS_WS_CLIENT_TYPE = 'js-websocket';\n  JS_WS_CLIENT_VERSION = '0.0.1';\n\n  decodeIO_encoder = null;\n  decodeIO_decoder = null;\n  EventEmitter = Emitter;\n\n  RES_OK = 200;\n  RES_FAIL = 500;\n  RES_OLD_CLIENT = 501;\n\n  socket = null;\n  reqId = 0;\n  callbacks = {}; //[id:string]{target: Object, success: Function, failed: Function}\n  handlers = {};\n  //map from request id to route\n  routeMap = {};\n  dict = {};    // route string to code\n  abbrs = {};   // code to route string\n  heartbeatInterval = 0;\n  heartbeatTimeout = 0;\n  nextHeartbeatTimeout = 0;\n  gapThreshold = 100;   // heartbeat gap threashold\n  heartbeatId = null;\n  heartbeatTimeoutId = null;\n  handshakeCallback = null;\n  decode = null;\n  encode = null;\n  reconnect = false;\n  reconncetTimer = null;\n  reconnectUrl = null;\n  reconnectAttempts = 0;\n  reconnectionDelay = 5000;\n  DEFAULT_MAX_RECONNECT_ATTEMPTS = 10;\n  targetObj = null\n  initCallback = null;\n  handler: any = {};\n\n  constructor() {\n    super()\n    this.handlers[Package.TYPE_HANDSHAKE] = this.handshake;\n    this.handlers[Package.TYPE_HEARTBEAT] = this.heartbeat;\n    this.handlers[Package.TYPE_DATA] = this.onData;\n    this.handlers[Package.TYPE_KICK] = this.onKick;\n  }\n\n  handshakeBuffer = {\n    'sys': {\n      type: this.JS_WS_CLIENT_TYPE,\n      version: this.JS_WS_CLIENT_VERSION,\n      rsa: {}\n    },\n    'user': {\n    }\n  };\n\n  public init(params, cb, target) {\n    this.initCallback = cb;\n    this.targetObj = target;\n    var host = params.host;\n    var port = params.port;\n    var path = params.path;\n\n    this.encode = params.encode || this.defaultEncode;\n    this.decode = params.decode || this.defaultDecode;\n\n    var url = 'ws://' + host;\n    if (port) {\n      url += ':' + port;\n    }\n\n    if (path) {\n      url += path;\n    }\n\n    this.handshakeBuffer.user = params.user;\n    this.handshakeCallback = params.handshakeCallback;\n    this.connect(params, url, cb);\n  };\n\n  private defaultDecode(data) {\n    var msg = Message.decode(data);\n\n    if (msg.id > 0) {\n      msg.route = this.routeMap[msg.id];\n      delete this.routeMap[msg.id];\n      if (!msg.route) {\n        return;\n      }\n    }\n\n    msg.body = this.deCompose(msg);\n    return msg;\n  };\n\n  private defaultEncode(reqId, route, msg) {\n    var type = reqId ? Message.TYPE_REQUEST : Message.TYPE_NOTIFY;\n    msg = Protocol.strencode(JSON.stringify(msg));\n\n    var compressRoute = 0;\n    if (this.dict && this.dict[route]) {\n      route = this.dict[route];\n      compressRoute = 1;\n    }\n\n    return Message.encode(reqId, type, compressRoute, route, msg);\n  };\n\n  private connect(params, url, cb) {\n    console.log('connect to ' + url);\n\n    var params = params || {};\n    var maxReconnectAttempts = params.maxReconnectAttempts || this.DEFAULT_MAX_RECONNECT_ATTEMPTS;\n    this.reconnectUrl = url;\n    var self = this;\n    var onopen = function (event) {\n      if (!!self.reconnect) {\n        self.emit('reconnect');\n      }\n      self.reset();\n      console.log(\"connect success\")\n      console.log(\"begin ack\")\n      var obj = Package.encode(Package.TYPE_HANDSHAKE, Protocol.strencode(JSON.stringify(self.handshakeBuffer)));\n      self.send(obj);\n    };\n    var onmessage = function (event) {\n      self.processPackage(Package.decode(event.data));\n      // new package arrived, update the heartbeat timeout\n      if (self.heartbeatTimeout) {\n        self.nextHeartbeatTimeout = Date.now() + self.heartbeatTimeout;\n      }\n    };\n    var onerror = function (event) {\n      self.emit('io-error', event);\n      console.error('socket error: ', event);\n    };\n    var onclose = function (event) {\n      self.emit('close', event);\n      self.emit('disconnect', event);\n      console.log('socket close: ', event);\n      if (!!params.reconnect && self.reconnectAttempts < maxReconnectAttempts) {\n        self.reconnect = true;\n        self.reconnectAttempts++;\n        self.reconncetTimer = setTimeout(() => {\n          self.connect(params, self.reconnectUrl, cb);\n        }, self.reconnectionDelay);\n        self.reconnectionDelay *= 2;\n      }\n    };\n    this.socket = new WebSocket(url);\n    this.socket.binaryType = 'arraybuffer';\n    this.socket.onopen = onopen;\n    this.socket.onmessage = onmessage;\n    this.socket.onerror = onerror;\n    this.socket.onclose = onclose;\n  };\n\n  public disconnect() {\n    if (this.socket) {\n      if (this.socket.disconnect) this.socket.disconnect();\n      if (this.socket.close) this.socket.close();\n      console.log('disconnect');\n      this.socket = null;\n    }\n\n    if (this.heartbeatId) {\n      clearTimeout(this.heartbeatId);\n      this.heartbeatId = null;\n    }\n    if (this.heartbeatTimeoutId) {\n      clearTimeout(this.heartbeatTimeoutId);\n      this.heartbeatTimeoutId = null;\n    }\n  };\n\n  public reset() {\n    this.reconnect = false;\n    this.reconnectionDelay = 1000 * 5;\n    this.reconnectAttempts = 0;\n    clearTimeout(this.reconncetTimer);\n  };\n\n  public request(route: string, msg: any, cb: Function, thisObj: Object, fail: Function = null) {\n    if (arguments.length === 2 && typeof msg === 'function') {\n      cb = msg;\n      msg = {};\n    } else {\n      msg = msg || {};\n    }\n    route = route || msg.route;\n    if (!route) {\n      return;\n    }\n\n    this.reqId++;\n    this.sendMessage(this.reqId, route, msg);\n\n    this.callbacks[this.reqId] = { target: thisObj, success: cb, failed: fail };\n    this.routeMap[this.reqId] = route;\n  };\n\n  public notify(route, msg) {\n    msg = msg || {};\n    this.sendMessage(0, route, msg);\n  };\n\n  private sendMessage(reqId, route, msg) {\n    if (this.encode) {\n      msg = this.encode(reqId, route, msg);\n    }\n    var packet = Package.encode(Package.TYPE_DATA, msg);\n    this.send(packet);\n  };\n\n  private send(packet: ArrayBuffer) {\n    let buffer = new Uint8Array(packet.byteLength)\n    for (let i = 0; i < packet.byteLength; ++i) {\n      buffer[i] = packet[i]\n    }\n    this.socket.send(buffer);\n  };\n\n  private heartbeat(data) {\n    if (!this.heartbeatInterval) {\n      // no heartbeat\n      return;\n    }\n\n    var obj = Package.encode(Package.TYPE_HEARTBEAT, undefined);\n    if (this.heartbeatTimeoutId) {\n      clearTimeout(this.heartbeatTimeoutId);\n      this.heartbeatTimeoutId = null;\n    }\n\n    if (this.heartbeatId) {\n      // already in a heartbeat interval\n      return;\n    }\n    this.heartbeatId = setTimeout(() => {\n      this.heartbeatId = null;\n      this.send(obj);\n\n      this.nextHeartbeatTimeout = Date.now() + this.heartbeatTimeout;\n      this.heartbeatTimeoutId = setTimeout(() => {\n        this.heartbeatTimeoutCb\n      }, this.heartbeatTimeout);\n    }, this.heartbeatInterval);\n  };\n\n  private heartbeatTimeoutCb() {\n    var gap = this.nextHeartbeatTimeout - Date.now();\n    if (gap > this.gapThreshold) {\n      this.heartbeatTimeoutId = setTimeout(() => { this.heartbeatTimeoutCb }, gap);\n    } else {\n      console.error('server heartbeat timeout');\n      this.emit('heartbeat timeout');\n      this.disconnect();\n    }\n  };\n\n  private handshake(data) {\n    data = JSON.parse(Protocol.strdecode(data));\n    do {\n      if (data.code === this.RES_OLD_CLIENT) {\n        this.emit('error', 'client version not fullfill');\n        break\n      }\n\n      if (data.code !== this.RES_OK) {\n        this.emit('error', 'handshake fail');\n        break\n      }\n\n      this.handshakeInit(data);\n      var obj = Package.encode(Package.TYPE_HANDSHAKE_ACK, undefined);\n      this.send(obj);\n    } while (false)\n\n    if (this.initCallback && this.targetObj) {\n      this.initCallback.call(this.socket, data.code);\n    }\n  };\n\n  private onData(data) {\n    var msg = data;\n    if (this.decode) {\n      msg = this.decode(msg);\n    }\n    this.processMessage(msg);\n  };\n\n  private onKick(data) {\n    data = JSON.parse(Protocol.strdecode(data));\n    this.emit('onKick', data);\n  };\n\n  private processPackage(msgs) {\n    if (Array.isArray(msgs)) {\n      for (var i = 0; i < msgs.length; i++) {\n        var msg = msgs[i];\n        this.handlers[msg.type].call(this, msg.body);\n      }\n    } else {\n      this.handlers[msgs.type].call(this, msgs.body);\n    }\n  };\n  private processMessage(msg) {\n    if (!msg.id) {\n      // server push message\n      this.emit(msg.route, msg.body);\n      return;\n    }\n\n    //底层协议已经转换成json了\n    // try {\n    //   JSON.parse(msg.body);\n    // } catch (e) {\n    //   this.emit(NanoEvent.MSG_PRASE_ERR)\n    //   throw (\"socket json \");\n    // }\n\n    //if have a id then find the callback function with the request\n    var cb = this.callbacks[msg.id];\n\n    delete this.callbacks[msg.id];\n\n    if (typeof cb.success === 'function' && msg.body && msg.body.code != NanoCode.ErrorID) {\n      cb.target ? cb.success.call(cb.target, msg.body) : cb.success(msg.body)\n    }\n    else if (typeof cb.failed === 'function') {\n      cb.target ? cb.failed.call(cb.target, msg.body) : cb.failed(msg.body)\n    }\n    else {\n      throw (\"no deal function with callback\")\n    }\n  };\n\n  private processMessageBatch(msgs) {\n    for (var i = 0, l = msgs.length; i < l; i++) {\n      this.processMessage(msgs[i]);\n    }\n  };\n\n  private deCompose(msg) {\n    var route = msg.route;\n\n    //Decompose route from dict\n    if (msg.compressRoute) {\n      if (!this.abbrs[route]) {\n        return {};\n      }\n\n      route = msg.route = this.abbrs[route];\n    }\n    return JSON.parse(Protocol.strdecode(msg.body));\n  };\n\n  private handshakeInit(data) {\n    if (data.sys && data.sys.heartbeat) {\n      this.heartbeatInterval = data.sys.heartbeat * 1000;   // heartbeat interval\n      this.heartbeatTimeout = this.heartbeatInterval * 2;        // max heartbeat timeout\n    } else {\n      this.heartbeatInterval = 0;\n      this.heartbeatTimeout = 0;\n    }\n\n    this.initData(data);\n\n    if (typeof this.handshakeCallback === 'function') {\n      this.handshakeCallback(data.user);\n    }\n  };\n\n  private initData(data) {\n    if (!data || !data.sys) {\n      return;\n    }\n    this.dict = data.sys.dict;\n\n    //Init compress dict\n    if (this.dict) {\n      this.abbrs = {};\n\n      for (var route in this.dict) {\n        this.abbrs[this.dict[route]] = route;\n      }\n    }\n  }\n}\n\nvar NanoInstance = new Nano()\nexport { NanoInstance as Nano }","/**\n * \n * @param dest \n * @param doffset \n * @param src \n * @param soffset \n * @param length \n */\nfunction copyArray(dest, doffset, src, soffset, length) {\n  if ('function' === typeof src.copy) {\n    // Buffer\n    src.copy(dest, doffset, soffset, soffset + length);\n  } else {\n    // Uint8Array\n    for (var index = 0; index < length; index++) {\n      dest[doffset++] = src[soffset++];\n    }\n  }\n};\n\nexport class Protocol {\n  /**\n   * pomele client encode\n   * id message id;\n   * route message route\n   * msg message body\n   * socketio current support string\n   */\n  static strencode(str) {\n    var byteArray = new ArrayBuffer(str.length * 3);\n    var offset = 0;\n    for (var i = 0; i < str.length; i++) {\n      var charCode = str.charCodeAt(i);\n      var codes = null;\n      if (charCode <= 0x7f) {\n        codes = [charCode];\n      } else if (charCode <= 0x7ff) {\n        codes = [0xc0 | (charCode >> 6), 0x80 | (charCode & 0x3f)];\n      } else {\n        codes = [0xe0 | (charCode >> 12), 0x80 | ((charCode & 0xfc0) >> 6), 0x80 | (charCode & 0x3f)];\n      }\n      for (var j = 0; j < codes.length; j++) {\n        byteArray[offset] = codes[j];\n        ++offset;\n      }\n    }\n    var _buffer = new ArrayBuffer(offset);\n    copyArray(_buffer, 0, byteArray, 0, offset);\n    return _buffer;\n  };\n\n  /**\n   * client decode\n   * msg String data\n   * return Message Object\n   */\n  static strdecode(buffer: ArrayBuffer) {\n    var bytes = new Uint8Array(buffer.byteLength)\n    for(let i = 0; i < buffer.byteLength; ++i){\n      bytes[i]=buffer[i]\n    }\n    var array = [];\n    var offset = 0;\n    var charCode = 0;\n    var end = bytes.byteLength;\n    while (offset < end) {\n      if (bytes[offset] < 128) {\n        charCode = bytes[offset];\n        offset += 1;\n      } else if (bytes[offset] < 224) {\n        charCode = ((bytes[offset] & 0x3f) << 6) + (bytes[offset + 1] & 0x3f);\n        offset += 2;\n      } else {\n        charCode = ((bytes[offset] & 0x0f) << 12) + ((bytes[offset + 1] & 0x3f) << 6) + (bytes[offset + 2] & 0x3f);\n        offset += 3;\n      }\n      array.push(charCode);\n    }\n    return String.fromCharCode.apply(null, array);\n  };\n}\n\n\nexport class Package {\n  static PKG_HEAD_BYTES = 4;\n  static TYPE_HANDSHAKE = 1;\n  static TYPE_HANDSHAKE_ACK = 2;\n  static TYPE_HEARTBEAT = 3;\n  static TYPE_DATA = 4;\n  static TYPE_KICK = 5;\n\n  /**\n   * Package protocol encode.\n   *\n   * Pomelo package format:\n   * +------+-------------+------------------+\n   * | type | body length |       body       |\n   * +------+-------------+------------------+\n   *\n   * Head: 4bytes\n   *   0: package type,\n   *      1 - handshake,\n   *      2 - handshake ack,\n   *      3 - heartbeat,\n   *      4 - data\n   *      5 - kick\n   *   1 - 3: big-endian body length\n   * Body: body length bytes\n   *\n   * @param  {Number}    type   package type\n   * @param  {ArrayBuffer} body   body content in bytes\n   * @return {ArrayBuffer}        new byte array that contains encode result\n   */\n  static encode(type, body): ArrayBuffer {\n    var length = body ? body.byteLength : 0;\n    var buffer = new ArrayBuffer(Package.PKG_HEAD_BYTES + length);\n    var index = 0;\n    buffer[index++] = type & 0xff;\n    buffer[index++] = (length >> 16) & 0xff;\n    buffer[index++] = (length >> 8) & 0xff;\n    buffer[index++] = length & 0xff;\n    if (body) {\n      copyArray(buffer, index, body, 0, length);\n    }\n    return buffer;\n  };\n\n  /**\n   * Package protocol decode.\n   * See encode for package format.\n   *\n   * @param  {ArrayBuffer} buffer byte array containing package content\n   * @return {Object}           {type: package type, buffer: body byte array}\n   */\n  static decode(buffer: ArrayBuffer) {\n    var offset = 0;\n    var bytes = new Uint8Array(buffer);\n    var length = 0;\n    var rs = [];\n    while (offset < bytes.byteLength) {\n      var type = bytes[offset++];\n      length = ((bytes[offset++]) << 16 | (bytes[offset++]) << 8 | bytes[offset++]) >>> 0;\n      var body = length ? new ArrayBuffer(length) : null;\n      copyArray(body, 0, bytes, offset, length);\n      offset += length;\n      rs.push({ 'type': type, 'body': body });\n    }\n    return rs.length === 1 ? rs[0] : rs;\n  };\n}\n\n\nexport class Message {\n  static TYPE_REQUEST = 0;\n  static TYPE_NOTIFY = 1;\n  static TYPE_RESPONSE = 2;\n  static TYPE_PUSH = 3;\n\n  static MSG_FLAG_BYTES = 1;\n  static MSG_ROUTE_CODE_BYTES = 2;\n  static MSG_ID_MAX_BYTES = 5;\n  static MSG_ROUTE_LEN_BYTES = 1;\n\n  static MSG_ROUTE_CODE_MAX = 0xffff;\n\n  static MSG_COMPRESS_ROUTE_MASK = 0x1;\n  static MSG_TYPE_MASK = 0x7;\n\n\n  static msgHasId(type) {\n    return type === Message.TYPE_REQUEST || type === Message.TYPE_RESPONSE;\n  };\n\n  static msgHasRoute(type) {\n    return type === Message.TYPE_REQUEST || type === Message.TYPE_NOTIFY ||\n      type === Message.TYPE_PUSH;\n  };\n\n  static caculateMsgIdBytes(id) {\n    var len = 0;\n    do {\n      len += 1;\n      id >>= 7;\n    } while (id > 0);\n    return len;\n  };\n\n  static encodeMsgFlag(type, compressRoute, buffer, offset) {\n    if (type !== Message.TYPE_REQUEST && type !== Message.TYPE_NOTIFY &&\n      type !== Message.TYPE_RESPONSE && type !== Message.TYPE_PUSH) {\n      throw new Error('unkonw message type: ' + type);\n    }\n\n    buffer[offset] = (type << 1) | (compressRoute ? 1 : 0);\n\n    return offset + Message.MSG_FLAG_BYTES;\n  };\n\n  static encodeMsgId(id, buffer, offset) {\n    do {\n      var tmp = id % 128;\n      var next = Math.floor(id / 128);\n\n      if (next !== 0) {\n        tmp = tmp + 128;\n      }\n      buffer[offset++] = tmp;\n\n      id = next;\n    } while (id !== 0);\n\n    return offset;\n  };\n\n  static encodeMsgRoute(compressRoute, route, buffer, offset) {\n    if (compressRoute) {\n      if (route > Message.MSG_ROUTE_CODE_MAX) {\n        throw new Error('route number is overflow');\n      }\n\n      buffer[offset++] = (route >> 8) & 0xff;\n      buffer[offset++] = route & 0xff;\n    } else {\n      if (route) {\n        buffer[offset++] = route.byteLength & 0xff;\n        copyArray(buffer, offset, route, 0, route.byteLength);\n        offset += route.byteLength;\n      } else {\n        buffer[offset++] = 0;\n      }\n    }\n\n    return offset;\n  };\n\n  static encodeMsgBody(msg, buffer, offset) {\n    copyArray(buffer, offset, msg, 0, msg.byteLength);\n    return offset + msg.byteLength;\n  };\n\n\n  /**\n   * Message protocol encode.\n   *\n   * @param  {Number} id            message id\n   * @param  {Number} type          message type\n   * @param  {Number} compressRoute whether compress route\n   * @param  {Number|String} route  route code or route string\n   * @param  {Buffer} msg           message body bytes\n   * @return {Buffer}               encode result\n   */\n  static encode(id, type, compressRoute, route, msg) {\n    // caculate message max length\n    var idBytes = Message.msgHasId(type) ? Message.caculateMsgIdBytes(id) : 0;\n    var msgLen = Message.MSG_FLAG_BYTES + idBytes;\n\n    if (Message.msgHasRoute(type)) {\n      if (compressRoute) {\n        if (typeof route !== 'number') {\n          throw new Error('error flag for number route!');\n        }\n        msgLen += Message.MSG_ROUTE_CODE_BYTES;\n      } else {\n        msgLen += Message.MSG_ROUTE_LEN_BYTES;\n        if (route) {\n          route = Protocol.strencode(route);\n          if (route.length > 255) {\n            throw new Error('route maxlength is overflow');\n          }\n          msgLen += route.byteLength;\n        }\n      }\n    }\n\n    if (msg) {\n      msgLen += msg.byteLength;\n    }\n\n    var buffer = new ArrayBuffer(msgLen);\n    var offset = 0;\n\n    // add flag\n    offset = Message.encodeMsgFlag(type, compressRoute, buffer, offset);\n\n    // add message id\n    if (Message.msgHasId(type)) {\n      offset = Message.encodeMsgId(id, buffer, offset);\n    }\n\n    // add route\n    if (Message.msgHasRoute(type)) {\n      offset = Message.encodeMsgRoute(compressRoute, route, buffer, offset);\n    }\n\n    // add body\n    if (msg) {\n      offset = Message.encodeMsgBody(msg, buffer, offset);\n    }\n\n    return buffer;\n  };\n\n  /**\n   * Message protocol decode.\n   *\n   * @param  {Buffer|Uint8Array} buffer message bytes\n   * @return {Object}            message object\n   */\n  static decode(buffer) {\n    let bytes = new ArrayBuffer(buffer.byteLength)\n    for (let i = 0; i < buffer.byteLength; ++i) {\n      bytes[i] = buffer[i]\n    }\n    // var bytes = new ArrayBuffer(buffer);\n    var bytesLen = bytes.byteLength;\n    var offset = 0;\n    var id = 0;\n    var route = null;\n\n    // parse flag\n    var flag = bytes[offset++];\n    var compressRoute = flag & Message.MSG_COMPRESS_ROUTE_MASK;\n    var type = (flag >> 1) & Message.MSG_TYPE_MASK;\n\n    // parse id\n    if (Message.msgHasId(type)) {\n      var m = parseInt(bytes[offset]);\n      var i = 0;\n      do {\n        var m = parseInt(bytes[offset]);\n        id = id + ((m & 0x7f) * Math.pow(2, (7 * i)));\n        offset++;\n        i++;\n      } while (m >= 128);\n    }\n\n    // parse route\n    if (Message.msgHasRoute(type)) {\n      if (compressRoute) {\n        route = (bytes[offset++]) << 8 | bytes[offset++];\n      } else {\n        var routeLen = bytes[offset++];\n        if (routeLen) {\n          route = new ArrayBuffer(routeLen);\n          copyArray(route, 0, bytes, offset, routeLen);\n          route = Protocol.strdecode(route);\n        } else {\n          route = '';\n        }\n        offset += routeLen;\n      }\n    }\n\n    // parse body\n    var bodyLen = bytesLen - offset;\n    var body = new ArrayBuffer(bodyLen);\n\n    copyArray(body, 0, bytes, offset, bodyLen);\n\n    return {\n      'id': id, 'type': type, 'compressRoute': compressRoute,\n      'route': route, 'body': body\n    };\n  };\n\n}\n"],"sourceRoot":"/source/","file":"project.dev.js"}